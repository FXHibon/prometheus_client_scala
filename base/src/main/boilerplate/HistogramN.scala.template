package io.prometheus.client.scala.internal.histogram

import io.prometheus.client.scala._

[1..21#
/** This represents a Prometheus histogram with 2 labels.
  *
  * @param name The name of the histogram
  * @tparam N The singleton type for the histogram's name
  * @tparam L##1 The singleton string type for label ##1
[#  * @tparam L2 The singleton string type for label 2#
]
  */
final class Histogram2[N <: String, L##1 <: String, [#L2 <: String#]](val name: N, _buckets: Seq[Double])(_labels: String*) extends Collector[N] {
  val buckets = Histogram.bucketsWithInf(_buckets).zipWithIndex
  val labels = _labels.toList

  private[scala] val adders = new BucketedAdders[Tuple2[String, [#String#]]](buckets.size + 1, None)

  def observe(l##1: String, [#l2: String#])(v: Double): Unit =
    Histogram.observe(buckets, adders(l##1, [#l2#]), v)

  override def collect(): List[RegistryMetric] =
    adders.getAll.flatMap({
      case (labelValues, value) =>
        val labelsAndValues = labels.zip(labelValues.productIterator.asInstanceOf[Iterator[String]].toIterable)
        RegistryMetric(s"${name}_total" , labelsAndValues, value.last) ::
          RegistryMetric(s"${name}_sum", labelsAndValues, value(value.length - 2)) ::
          buckets.map { case (bucket, idx) =>
            RegistryMetric(s"${name}_bucket", ("le" -> Histogram.prometheusDoubleFormat(bucket)) :: labelsAndValues, value(idx))
          }
    })

  override def toString(): String =
    s"Histogram1($name, ${buckets.map(_._##1)})(${labels.mkString(",")})"
}#
]
